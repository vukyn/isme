---
type: "Auto Attached"
description: "Dependency injection patterns and configuration management for the Rainy project"
globs: internal/di/*,internal/config/*,internal/middlewares/*
alwaysApply: false
---

# Rainy Project - Dependency Injection & Configuration

## Dependency Injection Structure

### DI Builder Pattern

```go
func NewBuilder() *di.EnhancedBuilder {
    builder, err := di.NewEnhancedBuilder()
    if err != nil {
        log.New().Fatal("Failed to create builder", err)
    }

    builder.Add(defineConfig())
    builder.Add(defineDB())
    builder.Add(defineMiddleware())
    for _, def := range defineRepository() {
        builder.Add(def)
    }
    for _, def := range defineUsecase() {
        builder.Add(def)
    }
    return builder
}
```

### DI Naming Convention

-   Repository: `{domain}.repository`
-   UseCase: `{domain}.usecase`
-   Config: `config`
-   DB: `db`
-   Middleware: `middleware`

## Configuration Management

### Config Structure

```go
type Config struct {
    Logger struct {
        Mode  string `envconfig:"LOGGER_MODE"`
        Level string `envconfig:"LOGGER_LEVEL"`
    }
    Auth struct {
        AccessTokenSecretKey  string `envconfig:"AUTH_ACCESS_TOKEN_SECRET_KEY"`
        RefreshTokenSecretKey string `envconfig:"AUTH_REFRESH_TOKEN_SECRET_KEY"`
        AccessTokenExpireIn   int    `envconfig:"AUTH_ACCESS_TOKEN_EXPIRE_IN"`
        RefreshTokenExpireIn  int    `envconfig:"AUTH_REFRESH_TOKEN_EXPIRE_IN"`
    }
    DB struct {
        Host     string `envconfig:"DB_HOST"`
        Port     int    `envconfig:"DB_PORT"`
        User     string `envconfig:"DB_USER"`
        Password string `envconfig:"DB_PASSWORD"`
        DBName   string `envconfig:"DB_NAME"`
    }
    Graceful struct {
        Verbose               bool `envconfig:"GRACEFUL_VERBOSE"`
        StepDelay             int  `envconfig:"GRACEFUL_STEP_DELAY"`
        ServerShutdownTimeout int  `envconfig:"GRACEFUL_SERVER_SHUTDOWN_TIMEOUT"`
    }
}
```

### Configuration Guidelines

-   Use `envconfig` for environment variable binding
-   Use `godotenv` for .env file loading
-   Structure config with nested structs
-   Use descriptive environment variable names
-   Group related configuration together

### Config Loading

```go
func LoadConfig(envFiles ...string) (*Config, error) {
    err := godotenv.Load(envFiles...)
    if err != nil {
        return nil, err
    }

    cfg := new(Config)
    if err := envconfig.Process("", cfg); err != nil {
        return nil, err
    }

    return cfg, nil
}
```

## DI Definition Patterns

### Config Definition

```go
func defineConfig() di.Def {
    return di.Def{
        Name: "config",
        Build: func(ctn di.Container) (interface{}, error) {
            return config.LoadConfig()
        },
    }
}
```

### Database Definition

```go
func defineDB() di.Def {
    return di.Def{
        Name: "db",
        Build: func(ctn di.Container) (interface{}, error) {
            cfg := ctn.Get("config").(*config.Config)
            return setupDatabase(cfg)
        },
    }
}
```

### Repository Definition

```go
func defineRepository() []di.Def {
    return []di.Def{
        {
            Name: "user.repository",
            Build: func(ctn di.Container) (interface{}, error) {
                db := ctn.Get("db").(*bun.DB)
                return repository.NewRepository(db), nil
            },
        },
    }
}
```

### UseCase Definition

```go
func defineUsecase() []di.Def {
    return []di.Def{
        {
            Name: "user.usecase",
            Build: func(ctn di.Container) (interface{}, error) {
                repo := ctn.Get("user.repository").(repository.IRepository)
                cfg := ctn.Get("config").(*config.Config)
                return usecase.NewUseCase(repo, cfg), nil
            },
        },
    }
}
```

## DI Container Usage

### In Handlers

```go
func SignUp(c *fiber.Ctx) error {
    ctn := pkgCtx.GetDiContainerRequestFromFiberCtx(c)
    defer ctn.Delete()

    uc, err := idi.GetUserUsecase(ctn)
    if err != nil {
        return pkgHttp.Err(c, err)
    }

    // Use the usecase...
}
```

### Container Management

-   Always defer `ctn.Delete()` in handlers
-   Use request-scoped containers for handlers
-   Use application-scoped containers for services
-   Handle container errors appropriately

## Middleware DI Integration

### DI Container Middleware

```go
func DiContainerMiddleware(c *fiber.Ctx) error {
    requestContainer, err := app.App.SubContainer()
    if err != nil {
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
            "error": "Internal server error",
        })
    }

    pkgCtx.SetDiContainerRequestToFiberCtx(c, requestContainer)
    return c.Next()
}
```

### Middleware Definition

```go
func defineMiddleware() di.Def {
    return di.Def{
        Name: "middleware",
        Build: func(ctn di.Container) (interface{}, error) {
            cfg := ctn.Get("config").(*config.Config)
            return middleware.NewMiddleware(cfg), nil
        },
    }
}
```

## Error Handling in DI

### Builder Error Handling

```go
func NewBuilder() *di.EnhancedBuilder {
    builder, err := di.NewEnhancedBuilder()
    if err != nil {
        log.New().Fatal("Failed to create builder", err)
    }
    // ... rest of builder setup
}
```

### Container Error Handling

```go
func GetUserUsecase(ctn di.Container) (usecase.IUseCase, error) {
    uc, err := ctn.SafeGet("user.usecase")
    if err != nil {
        return nil, err
    }
    return uc.(usecase.IUseCase), nil
}
```

## Best Practices

1. **Separation of Concerns**: Separate DI definitions by concern
2. **Error Handling**: Always handle DI errors appropriately
3. **Container Lifecycle**: Manage container lifecycle properly
4. **Dependency Order**: Define dependencies in correct order
5. **Interface Usage**: Use interfaces for dependency injection
6. **Configuration**: Centralize configuration management
7. **Testing**: Use DI for testable code

## References

-   `internal/di/di.go` - Main DI builder
-   `internal/di/di_config.go` - Config definitions
-   `internal/di/di_db.go` - Database definitions
-   `internal/di/di_repo.go` - Repository definitions
-   `internal/di/di_usecase.go` - UseCase definitions
-   `internal/config/config.go` - Configuration structure
-   `internal/middlewares/di.go` - Middleware DI setup
